// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R6B
// for U-ERICSSON\ethbaat (ethbaat@HU-00000670) on Thu Feb 20 17:43:37 2020

// Copyright (c) 2000-2019 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "JsonBasicTypeOS.hh"

namespace JsonBasicTypeOS {

/* Literal string constants */

static const unsigned char module_checksum[] = { 0x54, 0xd1, 0x42, 0xc7, 0x05, 0xa4, 0x33, 0x5d, 0xd8, 0xae, 0xc2, 0xf2, 0xc0, 0x48, 0x08, 0x55 };

/* Global variable definitions */

const XERdescriptor_t       OS__json_xer_ = { {"OS_json>\n", "OS_json>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int OS__json_oer_ext_arr_[0] = {};
const int OS__json_oer_p_[0] = {};
const TTCN_OERdescriptor_t OS__json_oer_ = { -1, TRUE, -1, FALSE, 0, 0, OS__json_oer_ext_arr_, 0, OS__json_oer_p_};
const TTCN_Typedescriptor_t OS__json_descr_ = { "@JsonBasicTypeOS.OS_json", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &OS__json_xer_, &OCTETSTRING_json_, &OS__json_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING OS__json_default_coding("JSON");
TTCN_Module module_object("JsonBasicTypeOS", __DATE__, __TIME__, module_checksum, NULL, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_6,
  current_runtime_version.requires_patch_level_1,  current_runtime_version.requires_runtime_1);

/* Bodies of functions, altsteps and testcases */

void OS__json_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(OS__json_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER OS__json_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `octetstring' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(OS__json_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}


} /* end of namespace */
