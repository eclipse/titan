// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R6B
// for U-ERICSSON\ethbaat (ethbaat@HU-00000670) on Thu Feb 20 17:43:37 2020

// Copyright (c) 2000-2019 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef JsonBasicTypeFuncRef_HH
#define JsonBasicTypeFuncRef_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 60601
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef WIN32
#error This file should be compiled on WIN32
#endif

#undef JsonBasicTypeFuncRef_HH
#endif

namespace JsonBasicTypeFuncRef {

/* Forward declarations of classes */

class fooref;
class fooref_template;

} /* end of namespace */

#ifndef JsonBasicTypeFuncRef_HH
#define JsonBasicTypeFuncRef_HH

namespace JsonBasicTypeFuncRef {

/* Class definitions */

class fooref : public Base_Type {
public:
typedef CHARSTRING (*function_pointer)(const CHARSTRING& input);
typedef void (*start_pointer)(const COMPONENT& component_reference, const CHARSTRING& input);
private:
friend class fooref_template;
friend boolean operator==(fooref::function_pointer value, const fooref& other_value);
function_pointer referred_function;
public:
fooref();
fooref(function_pointer other_value);
fooref(const fooref& other_value);
fooref& operator=(function_pointer other_value);
fooref& operator=(const fooref& other_value);
boolean operator==(function_pointer other_value) const;
boolean operator==(const fooref& other_value) const;
inline boolean operator!=(function_pointer other_value) const
{ return !(*this == other_value); }
inline boolean operator!=(const fooref& other_value) const
{ return !(*this == other_value); }

CHARSTRING invoke(const CHARSTRING& input) const;
inline boolean is_bound() const { return referred_function != NULL; }
inline boolean is_value() const { return referred_function != NULL; }
inline void clean_up() { referred_function = NULL; }
inline void must_bound(const char *err_msg) const
{ if (referred_function == NULL) TTCN_error("%s", err_msg); }

inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

extern boolean operator==(fooref::function_pointer value, const fooref& other_value);
inline boolean operator!=(fooref::function_pointer value, const fooref& other_value)
{ return !(value == other_value); } 

class fooref_template : public Base_Template {
union {
fooref::function_pointer single_value;
struct {
unsigned int n_values;
fooref_template *list_value;
} value_list;
};

  void copy_template(const fooref_template& other_value);
public:
fooref_template();
fooref_template(template_sel other_value);
fooref_template(fooref::function_pointer other_value);
fooref_template(const fooref& other_value);
fooref_template(const OPTIONAL<fooref>& other_value);
fooref_template(const fooref_template& other_value);
~fooref_template();
void clean_up();
fooref_template& operator=(template_sel other_value);
fooref_template& operator=(fooref::function_pointer other_value);
fooref_template& operator=(const fooref& other_value);
fooref_template& operator=(const OPTIONAL<fooref>& other_value);
fooref_template& operator=(const fooref_template& other_value);
boolean match(fooref::function_pointer other_value, boolean legacy = FALSE) const;
boolean match(const fooref& other_value, boolean legacy = FALSE) const;
fooref valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
fooref_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const fooref& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};


/* Global variable declarations */

extern const TTCN_Typedescriptor_t fooref_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
