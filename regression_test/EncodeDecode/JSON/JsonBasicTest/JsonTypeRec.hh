// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R6B
// for U-ERICSSON\ethbaat (ethbaat@HU-00000670) on Thu Feb 20 17:43:37 2020

// Copyright (c) 2000-2019 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef JsonTypeRec_HH
#define JsonTypeRec_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 60601
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef WIN32
#error This file should be compiled on WIN32
#endif

#undef JsonTypeRec_HH
#endif

namespace JsonTypeRec {

/* Forward declarations of classes */

class R;
class R_template;

} /* end of namespace */

#ifndef JsonTypeRec_HH
#define JsonTypeRec_HH

namespace JsonTypeRec {

/* Class definitions */

class R : public Base_Type {
  INTEGER field_i;
  OPTIONAL<CHARSTRING> field_j;
public:
  R();
  R(const INTEGER& par_i,
    const OPTIONAL<CHARSTRING>& par_j);
  R(const R& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  R& operator=(const R& other_value);
  boolean operator==(const R& other_value) const;
  inline boolean operator!=(const R& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& i()
    {return field_i;}
  inline const INTEGER& i() const
    {return field_i;}
  inline OPTIONAL<CHARSTRING>& j()
    {return field_j;}
  inline const OPTIONAL<CHARSTRING>& j() const
    {return field_j;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean, int p_chosen_field = CHOSEN_FIELD_UNSET);
};

class R_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
R_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const R& other_value);
void copy_template(const R_template& other_value);

public:
R_template();
R_template(template_sel other_value);
R_template(const R& other_value);
R_template(const OPTIONAL<R>& other_value);
R_template(const R_template& other_value);
~R_template();
R_template& operator=(template_sel other_value);
R_template& operator=(const R& other_value);
R_template& operator=(const OPTIONAL<R>& other_value);
R_template& operator=(const R_template& other_value);
boolean match(const R& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
R valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
R_template& list_item(unsigned int list_index) const;
INTEGER_template& i();
const INTEGER_template& i() const;
CHARSTRING_template& j();
const CHARSTRING_template& j() const;
int size_of() const;
void log() const;
void log_match(const R& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern void R_i_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER R_i_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void R_j_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER R_j_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void R_encoder(const R& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER R_decoder(OCTETSTRING& input_stream, R& output_value, const UNIVERSAL_CHARSTRING& coding_name);

/* Global variable declarations */

extern const XERdescriptor_t R_i_xer_;
extern const TTCN_Typedescriptor_t R_i_descr_;
extern UNIVERSAL_CHARSTRING R_i_default_coding;
extern const TTCN_JSONdescriptor_t R_json_;
extern const TTCN_Typedescriptor_t R_descr_;
extern const XERdescriptor_t R_j_xer_;
extern const TTCN_Typedescriptor_t R_j_descr_;
extern UNIVERSAL_CHARSTRING R_j_default_coding;
extern UNIVERSAL_CHARSTRING R_default_coding;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
