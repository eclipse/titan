// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R6B
// for U-ERICSSON\ethbaat (ethbaat@HU-00000670) on Thu Feb 20 17:43:37 2020

// Copyright (c) 2000-2019 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef JsonBasicTypes_HH
#define JsonBasicTypes_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 60601
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef WIN32
#error This file should be compiled on WIN32
#endif

#undef JsonBasicTypes_HH
#endif

namespace JsonBasicTypes {

/* Forward declarations of classes */

class E__json;
class E__json_template;
class AI3__json;
class R__json;
class R__json_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER RoI__json;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template RoI__json_template;
class S__json;
class S__json_template;
typedef PreGenRecordOf::PREGEN__SET__OF__INTEGER SoI__json;
typedef PreGenRecordOf::PREGEN__SET__OF__INTEGER_template SoI__json_template;
class U__json;
class U__json_template;

} /* end of namespace */

#ifndef JsonBasicTypes_HH
#define JsonBasicTypes_HH

namespace JsonBasicTypes {

/* Type definitions */

typedef INTEGER I__json;
typedef INTEGER_template I__json_template;
typedef FLOAT F__json;
typedef FLOAT_template F__json_template;
typedef BOOLEAN B__json;
typedef BOOLEAN_template B__json_template;
typedef BITSTRING BS__json;
typedef BITSTRING_template BS__json_template;
typedef CHARSTRING CS__json;
typedef CHARSTRING_template CS__json_template;
typedef HEXSTRING HS__json;
typedef HEXSTRING_template HS__json_template;
typedef OCTETSTRING OS__json;
typedef OCTETSTRING_template OS__json_template;
typedef UNIVERSAL_CHARSTRING UCS__json;
typedef UNIVERSAL_CHARSTRING_template UCS__json_template;
typedef TEMPLATE_ARRAY<INTEGER, INTEGER_template, 3, 0> AI3__json_template;
typedef VERDICTTYPE V__json;
typedef VERDICTTYPE_template V__json_template;

/* Class definitions */

class E__json : public Base_Type { // enum
friend class E__json_template;
public:
enum enum_type { first = 0, second = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
E__json();
E__json(int other_value);
E__json(enum_type other_value);
E__json(const E__json& other_value);

E__json& operator=(int other_value);
E__json& operator=(enum_type other_value);
E__json& operator=(const E__json& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const E__json& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const E__json& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const E__json& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const E__json& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const E__json& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const E__json& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const E__json& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean, int p_chosen_field = CHOSEN_FIELD_UNSET);
};

class E__json_template : public Base_Template {
union {
E__json::enum_type single_value;
struct {
unsigned int n_values;
E__json_template *list_value;
} value_list;
};

void copy_template(const E__json_template& other_value);

public:
E__json_template();
E__json_template(template_sel other_value);
E__json_template(int other_value);
E__json_template(E__json::enum_type other_value);
E__json_template(const E__json& other_value);
E__json_template(const OPTIONAL<E__json>& other_value);
E__json_template(const E__json_template& other_value);
~E__json_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
E__json_template& operator=(template_sel other_value);
E__json_template& operator=(int other_value);
E__json_template& operator=(E__json::enum_type other_value);
E__json_template& operator=(const E__json& other_value);
E__json_template& operator=(const OPTIONAL<E__json>& other_value);
E__json_template& operator=(const E__json_template& other_value);

boolean match(E__json::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const E__json& other_value, boolean legacy = FALSE) const;
E__json::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
E__json_template& list_item(unsigned int list_index);
void log() const;
void log_match(const E__json& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class AI3__json : public VALUE_ARRAY<INTEGER, 3, 0> {
const TTCN_Typedescriptor_t* get_elem_descr() const;
public:
AI3__json(): VALUE_ARRAY<INTEGER, 3, 0>() {}
AI3__json(const VALUE_ARRAY<INTEGER, 3, 0>& p): VALUE_ARRAY<INTEGER, 3, 0>(p) {}
};

class R__json : public Base_Type {
  INTEGER field_i;
  BITSTRING field_bs;
  CHARSTRING field_cs;
  HEXSTRING field_hs;
  OCTETSTRING field_os;
  UNIVERSAL_CHARSTRING field_ucs;
  E__json field_e;
public:
  R__json();
  R__json(const INTEGER& par_i,
    const BITSTRING& par_bs,
    const CHARSTRING& par_cs,
    const HEXSTRING& par_hs,
    const OCTETSTRING& par_os,
    const UNIVERSAL_CHARSTRING& par_ucs,
    const E__json& par_e);
  R__json(const R__json& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  R__json& operator=(const R__json& other_value);
  boolean operator==(const R__json& other_value) const;
  inline boolean operator!=(const R__json& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& i()
    {return field_i;}
  inline const INTEGER& i() const
    {return field_i;}
  inline BITSTRING& bs()
    {return field_bs;}
  inline const BITSTRING& bs() const
    {return field_bs;}
  inline CHARSTRING& cs()
    {return field_cs;}
  inline const CHARSTRING& cs() const
    {return field_cs;}
  inline HEXSTRING& hs()
    {return field_hs;}
  inline const HEXSTRING& hs() const
    {return field_hs;}
  inline OCTETSTRING& os()
    {return field_os;}
  inline const OCTETSTRING& os() const
    {return field_os;}
  inline UNIVERSAL_CHARSTRING& ucs()
    {return field_ucs;}
  inline const UNIVERSAL_CHARSTRING& ucs() const
    {return field_ucs;}
  inline E__json& e()
    {return field_e;}
  inline const E__json& e() const
    {return field_e;}
  inline int size_of() const
    {return 7;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean, int p_chosen_field = CHOSEN_FIELD_UNSET);
};

class R__json_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
R__json_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const R__json& other_value);
void copy_template(const R__json_template& other_value);

public:
R__json_template();
R__json_template(template_sel other_value);
R__json_template(const R__json& other_value);
R__json_template(const OPTIONAL<R__json>& other_value);
R__json_template(const R__json_template& other_value);
~R__json_template();
R__json_template& operator=(template_sel other_value);
R__json_template& operator=(const R__json& other_value);
R__json_template& operator=(const OPTIONAL<R__json>& other_value);
R__json_template& operator=(const R__json_template& other_value);
boolean match(const R__json& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
R__json valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
R__json_template& list_item(unsigned int list_index) const;
INTEGER_template& i();
const INTEGER_template& i() const;
BITSTRING_template& bs();
const BITSTRING_template& bs() const;
CHARSTRING_template& cs();
const CHARSTRING_template& cs() const;
HEXSTRING_template& hs();
const HEXSTRING_template& hs() const;
OCTETSTRING_template& os();
const OCTETSTRING_template& os() const;
UNIVERSAL_CHARSTRING_template& ucs();
const UNIVERSAL_CHARSTRING_template& ucs() const;
E__json_template& e();
const E__json_template& e() const;
int size_of() const;
void log() const;
void log_match(const R__json& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class S__json : public Base_Type {
  INTEGER field_i;
  BITSTRING field_bs;
  CHARSTRING field_cs;
  HEXSTRING field_hs;
  OCTETSTRING field_os;
  UNIVERSAL_CHARSTRING field_ucs;
  E__json field_e;
public:
  S__json();
  S__json(const INTEGER& par_i,
    const BITSTRING& par_bs,
    const CHARSTRING& par_cs,
    const HEXSTRING& par_hs,
    const OCTETSTRING& par_os,
    const UNIVERSAL_CHARSTRING& par_ucs,
    const E__json& par_e);
  S__json(const S__json& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  S__json& operator=(const S__json& other_value);
  boolean operator==(const S__json& other_value) const;
  inline boolean operator!=(const S__json& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& i()
    {return field_i;}
  inline const INTEGER& i() const
    {return field_i;}
  inline BITSTRING& bs()
    {return field_bs;}
  inline const BITSTRING& bs() const
    {return field_bs;}
  inline CHARSTRING& cs()
    {return field_cs;}
  inline const CHARSTRING& cs() const
    {return field_cs;}
  inline HEXSTRING& hs()
    {return field_hs;}
  inline const HEXSTRING& hs() const
    {return field_hs;}
  inline OCTETSTRING& os()
    {return field_os;}
  inline const OCTETSTRING& os() const
    {return field_os;}
  inline UNIVERSAL_CHARSTRING& ucs()
    {return field_ucs;}
  inline const UNIVERSAL_CHARSTRING& ucs() const
    {return field_ucs;}
  inline E__json& e()
    {return field_e;}
  inline const E__json& e() const
    {return field_e;}
  inline int size_of() const
    {return 7;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean, int p_chosen_field = CHOSEN_FIELD_UNSET);
};

class S__json_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
S__json_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const S__json& other_value);
void copy_template(const S__json_template& other_value);

public:
S__json_template();
S__json_template(template_sel other_value);
S__json_template(const S__json& other_value);
S__json_template(const OPTIONAL<S__json>& other_value);
S__json_template(const S__json_template& other_value);
~S__json_template();
S__json_template& operator=(template_sel other_value);
S__json_template& operator=(const S__json& other_value);
S__json_template& operator=(const OPTIONAL<S__json>& other_value);
S__json_template& operator=(const S__json_template& other_value);
boolean match(const S__json& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
S__json valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
S__json_template& list_item(unsigned int list_index) const;
INTEGER_template& i();
const INTEGER_template& i() const;
BITSTRING_template& bs();
const BITSTRING_template& bs() const;
CHARSTRING_template& cs();
const CHARSTRING_template& cs() const;
HEXSTRING_template& hs();
const HEXSTRING_template& hs() const;
OCTETSTRING_template& os();
const OCTETSTRING_template& os() const;
UNIVERSAL_CHARSTRING_template& ucs();
const UNIVERSAL_CHARSTRING_template& ucs() const;
E__json_template& e();
const E__json_template& e() const;
int size_of() const;
void log() const;
void log_match(const S__json& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class U__json : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_i = 1, ALT_bs = 2, ALT_cs = 3, ALT_hs = 4, ALT_os = 5, ALT_ucs = 6, ALT_e = 7 };
private:
union_selection_type union_selection;
union {
INTEGER *field_i;
BITSTRING *field_bs;
CHARSTRING *field_cs;
HEXSTRING *field_hs;
OCTETSTRING *field_os;
UNIVERSAL_CHARSTRING *field_ucs;
E__json *field_e;
};
void copy_value(const U__json& other_value);

public:
U__json();
U__json(const U__json& other_value);
~U__json();
U__json& operator=(const U__json& other_value);
boolean operator==(const U__json& other_value) const;
inline boolean operator!=(const U__json& other_value) const { return !(*this == other_value); }
INTEGER& i();
const INTEGER& i() const;
BITSTRING& bs();
const BITSTRING& bs() const;
CHARSTRING& cs();
const CHARSTRING& cs() const;
HEXSTRING& hs();
const HEXSTRING& hs() const;
OCTETSTRING& os();
const OCTETSTRING& os() const;
UNIVERSAL_CHARSTRING& ucs();
const UNIVERSAL_CHARSTRING& ucs() const;
E__json& e();
const E__json& e() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean, int p_chosen_field = CHOSEN_FIELD_UNSET);
};

class U__json_template : public Base_Template {
union {
struct {
U__json::union_selection_type union_selection;
union {
INTEGER_template *field_i;
BITSTRING_template *field_bs;
CHARSTRING_template *field_cs;
HEXSTRING_template *field_hs;
OCTETSTRING_template *field_os;
UNIVERSAL_CHARSTRING_template *field_ucs;
E__json_template *field_e;
};
} single_value;
struct {
unsigned int n_values;
U__json_template *list_value;
} value_list;
};
void copy_value(const U__json& other_value);

void copy_template(const U__json_template& other_value);

public:
U__json_template();
U__json_template(template_sel other_value);
U__json_template(const U__json& other_value);
U__json_template(const OPTIONAL<U__json>& other_value);
U__json_template(const U__json_template& other_value);
~U__json_template();
void clean_up();
U__json_template& operator=(template_sel other_value);
U__json_template& operator=(const U__json& other_value);
U__json_template& operator=(const OPTIONAL<U__json>& other_value);
U__json_template& operator=(const U__json_template& other_value);
boolean match(const U__json& other_value, boolean legacy = FALSE) const;
boolean is_value() const;U__json valueof() const;
U__json_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
INTEGER_template& i();
const INTEGER_template& i() const;
BITSTRING_template& bs();
const BITSTRING_template& bs() const;
CHARSTRING_template& cs();
const CHARSTRING_template& cs() const;
HEXSTRING_template& hs();
const HEXSTRING_template& hs() const;
OCTETSTRING_template& os();
const OCTETSTRING_template& os() const;
UNIVERSAL_CHARSTRING_template& ucs();
const UNIVERSAL_CHARSTRING_template& ucs() const;
E__json_template& e();
const E__json_template& e() const;
boolean ischosen(U__json::union_selection_type checked_selection) const;
void log() const;
void log_match(const U__json& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};


/* Function prototypes */

extern void I__json_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER I__json_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void F__json_encoder(const FLOAT& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER F__json_decoder(OCTETSTRING& input_stream, FLOAT& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void E__json_encoder(const E__json& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER E__json_decoder(OCTETSTRING& input_stream, E__json& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void B__json_encoder(const BOOLEAN& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER B__json_decoder(OCTETSTRING& input_stream, BOOLEAN& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void BS__json_encoder(const BITSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER BS__json_decoder(OCTETSTRING& input_stream, BITSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void CS__json_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER CS__json_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void HS__json_encoder(const HEXSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER HS__json_decoder(OCTETSTRING& input_stream, HEXSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void OS__json_encoder(const OCTETSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER OS__json_decoder(OCTETSTRING& input_stream, OCTETSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void UCS__json_encoder(const UNIVERSAL_CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER UCS__json_decoder(OCTETSTRING& input_stream, UNIVERSAL_CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void AI3__json_0_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER AI3__json_0_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void AI3__json_encoder(const AI3__json& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER AI3__json_decoder(OCTETSTRING& input_stream, AI3__json& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void V__json_encoder(const VERDICTTYPE& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER V__json_decoder(OCTETSTRING& input_stream, VERDICTTYPE& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void R__json_encoder(const R__json& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER R__json_decoder(OCTETSTRING& input_stream, R__json& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void RoI__json_0_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER RoI__json_0_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void RoI__json_encoder(const RoI__json& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER RoI__json_decoder(OCTETSTRING& input_stream, RoI__json& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void S__json_encoder(const S__json& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER S__json_decoder(OCTETSTRING& input_stream, S__json& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void SoI__json_0_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER SoI__json_0_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void SoI__json_encoder(const SoI__json& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER SoI__json_decoder(OCTETSTRING& input_stream, SoI__json& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void U__json_encoder(const U__json& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER U__json_decoder(OCTETSTRING& input_stream, U__json& output_value, const UNIVERSAL_CHARSTRING& coding_name);

/* Global variable declarations */

extern const XERdescriptor_t I__json_xer_;
extern const TTCN_OERdescriptor_t I__json_oer_;
extern const TTCN_Typedescriptor_t I__json_descr_;
extern UNIVERSAL_CHARSTRING I__json_default_coding;
extern const XERdescriptor_t F__json_xer_;
extern const TTCN_OERdescriptor_t F__json_oer_;
extern const TTCN_Typedescriptor_t F__json_descr_;
extern UNIVERSAL_CHARSTRING F__json_default_coding;
extern const TTCN_JSONdescriptor_t E__json_json_;
extern const TTCN_Typedescriptor_t E__json_descr_;
extern UNIVERSAL_CHARSTRING E__json_default_coding;
extern const XERdescriptor_t B__json_xer_;
extern const TTCN_OERdescriptor_t B__json_oer_;
extern const TTCN_Typedescriptor_t B__json_descr_;
extern UNIVERSAL_CHARSTRING B__json_default_coding;
extern const XERdescriptor_t BS__json_xer_;
extern const TTCN_Typedescriptor_t BS__json_descr_;
extern UNIVERSAL_CHARSTRING BS__json_default_coding;
extern const XERdescriptor_t CS__json_xer_;
extern const TTCN_Typedescriptor_t CS__json_descr_;
extern UNIVERSAL_CHARSTRING CS__json_default_coding;
extern const XERdescriptor_t HS__json_xer_;
extern const TTCN_Typedescriptor_t HS__json_descr_;
extern UNIVERSAL_CHARSTRING HS__json_default_coding;
extern const XERdescriptor_t OS__json_xer_;
extern const TTCN_OERdescriptor_t OS__json_oer_;
extern const TTCN_Typedescriptor_t OS__json_descr_;
extern UNIVERSAL_CHARSTRING OS__json_default_coding;
extern const XERdescriptor_t UCS__json_xer_;
extern const TTCN_Typedescriptor_t UCS__json_descr_;
extern UNIVERSAL_CHARSTRING UCS__json_default_coding;
extern const XERdescriptor_t AI3__json_0_xer_;
extern const TTCN_Typedescriptor_t AI3__json_0_descr_;
extern UNIVERSAL_CHARSTRING AI3__json_0_default_coding;
extern const TTCN_JSONdescriptor_t AI3__json_json_;
extern const TTCN_Typedescriptor_t AI3__json_descr_;
extern UNIVERSAL_CHARSTRING AI3__json_default_coding;
extern const XERdescriptor_t V__json_xer_;
extern const TTCN_Typedescriptor_t V__json_descr_;
extern UNIVERSAL_CHARSTRING V__json_default_coding;
extern const XERdescriptor_t R__json_i_xer_;
extern const TTCN_OERdescriptor_t R__json_i_oer_;
extern const TTCN_Typedescriptor_t R__json_i_descr_;
extern UNIVERSAL_CHARSTRING R__json_i_default_coding;
extern const XERdescriptor_t R__json_bs_xer_;
extern const TTCN_OERdescriptor_t R__json_bs_oer_;
extern const TTCN_Typedescriptor_t R__json_bs_descr_;
extern UNIVERSAL_CHARSTRING R__json_bs_default_coding;
extern const XERdescriptor_t R__json_cs_xer_;
extern const TTCN_Typedescriptor_t R__json_cs_descr_;
extern UNIVERSAL_CHARSTRING R__json_cs_default_coding;
extern const XERdescriptor_t R__json_hs_xer_;
extern const TTCN_Typedescriptor_t R__json_hs_descr_;
extern UNIVERSAL_CHARSTRING R__json_hs_default_coding;
extern const XERdescriptor_t R__json_os_xer_;
extern const TTCN_OERdescriptor_t R__json_os_oer_;
extern const TTCN_Typedescriptor_t R__json_os_descr_;
extern UNIVERSAL_CHARSTRING R__json_os_default_coding;
extern const XERdescriptor_t R__json_ucs_xer_;
extern const TTCN_Typedescriptor_t R__json_ucs_descr_;
extern UNIVERSAL_CHARSTRING R__json_ucs_default_coding;
extern const TTCN_Typedescriptor_t R__json_e_descr_;
extern UNIVERSAL_CHARSTRING R__json_e_default_coding;
extern const TTCN_JSONdescriptor_t R__json_json_;
extern const TTCN_Typedescriptor_t R__json_descr_;
extern UNIVERSAL_CHARSTRING R__json_default_coding;
extern const TTCN_JSONdescriptor_t RoI__json_json_;
extern const TTCN_Typedescriptor_t RoI__json_descr_;
extern const XERdescriptor_t RoI__json_0_xer_;
extern const TTCN_Typedescriptor_t RoI__json_0_descr_;
extern UNIVERSAL_CHARSTRING RoI__json_0_default_coding;
extern UNIVERSAL_CHARSTRING RoI__json_default_coding;
extern const XERdescriptor_t S__json_i_xer_;
extern const TTCN_OERdescriptor_t S__json_i_oer_;
extern const TTCN_Typedescriptor_t S__json_i_descr_;
extern UNIVERSAL_CHARSTRING S__json_i_default_coding;
extern const XERdescriptor_t S__json_bs_xer_;
extern const TTCN_OERdescriptor_t S__json_bs_oer_;
extern const TTCN_Typedescriptor_t S__json_bs_descr_;
extern UNIVERSAL_CHARSTRING S__json_bs_default_coding;
extern const XERdescriptor_t S__json_cs_xer_;
extern const TTCN_Typedescriptor_t S__json_cs_descr_;
extern UNIVERSAL_CHARSTRING S__json_cs_default_coding;
extern const XERdescriptor_t S__json_hs_xer_;
extern const TTCN_Typedescriptor_t S__json_hs_descr_;
extern UNIVERSAL_CHARSTRING S__json_hs_default_coding;
extern const XERdescriptor_t S__json_os_xer_;
extern const TTCN_OERdescriptor_t S__json_os_oer_;
extern const TTCN_Typedescriptor_t S__json_os_descr_;
extern UNIVERSAL_CHARSTRING S__json_os_default_coding;
extern const XERdescriptor_t S__json_ucs_xer_;
extern const TTCN_Typedescriptor_t S__json_ucs_descr_;
extern UNIVERSAL_CHARSTRING S__json_ucs_default_coding;
extern const TTCN_Typedescriptor_t S__json_e_descr_;
extern UNIVERSAL_CHARSTRING S__json_e_default_coding;
extern const TTCN_JSONdescriptor_t S__json_json_;
extern const TTCN_Typedescriptor_t S__json_descr_;
extern UNIVERSAL_CHARSTRING S__json_default_coding;
extern const TTCN_JSONdescriptor_t SoI__json_json_;
extern const TTCN_Typedescriptor_t SoI__json_descr_;
extern const XERdescriptor_t SoI__json_0_xer_;
extern const TTCN_Typedescriptor_t SoI__json_0_descr_;
extern UNIVERSAL_CHARSTRING SoI__json_0_default_coding;
extern UNIVERSAL_CHARSTRING SoI__json_default_coding;
extern const TTCN_JSONdescriptor_t U__json_json_;
extern const TTCN_Typedescriptor_t U__json_descr_;
extern const XERdescriptor_t U__json_i_xer_;
extern const TTCN_OERdescriptor_t U__json_i_oer_;
extern const TTCN_Typedescriptor_t U__json_i_descr_;
extern UNIVERSAL_CHARSTRING U__json_i_default_coding;
extern const XERdescriptor_t U__json_bs_xer_;
extern const TTCN_OERdescriptor_t U__json_bs_oer_;
extern const TTCN_Typedescriptor_t U__json_bs_descr_;
extern UNIVERSAL_CHARSTRING U__json_bs_default_coding;
extern const XERdescriptor_t U__json_cs_xer_;
extern const TTCN_Typedescriptor_t U__json_cs_descr_;
extern UNIVERSAL_CHARSTRING U__json_cs_default_coding;
extern const XERdescriptor_t U__json_hs_xer_;
extern const TTCN_Typedescriptor_t U__json_hs_descr_;
extern UNIVERSAL_CHARSTRING U__json_hs_default_coding;
extern const XERdescriptor_t U__json_os_xer_;
extern const TTCN_OERdescriptor_t U__json_os_oer_;
extern const TTCN_Typedescriptor_t U__json_os_descr_;
extern UNIVERSAL_CHARSTRING U__json_os_default_coding;
extern const XERdescriptor_t U__json_ucs_xer_;
extern const TTCN_Typedescriptor_t U__json_ucs_descr_;
extern UNIVERSAL_CHARSTRING U__json_ucs_default_coding;
extern const TTCN_Typedescriptor_t U__json_e_descr_;
extern UNIVERSAL_CHARSTRING U__json_e_default_coding;
extern UNIVERSAL_CHARSTRING U__json_default_coding;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
