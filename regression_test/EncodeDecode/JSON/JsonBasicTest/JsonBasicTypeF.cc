// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R6B
// for U-ERICSSON\ethbaat (ethbaat@HU-00000670) on Thu Feb 20 17:43:37 2020

// Copyright (c) 2000-2019 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "JsonBasicTypeF.hh"

namespace JsonBasicTypeF {

/* Literal string constants */

static const unsigned char module_checksum[] = { 0x7f, 0xf4, 0x6a, 0xc0, 0x3b, 0x14, 0x5d, 0x7b, 0x84, 0x8b, 0x88, 0xb3, 0x05, 0x73, 0x99, 0xf3 };

/* Global variable definitions */

const XERdescriptor_t       F__json_xer_ = { {"F_json>\n", "F_json>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int F__json_oer_ext_arr_[0] = {};
const int F__json_oer_p_[0] = {};
const TTCN_OERdescriptor_t F__json_oer_ = { -1, TRUE, -1, FALSE, 0, 0, F__json_oer_ext_arr_, 0, F__json_oer_p_};
const TTCN_Typedescriptor_t F__json_descr_ = { "@JsonBasicTypeF.F_json", &FLOAT_ber_, &FLOAT_raw_, NULL, &F__json_xer_, &FLOAT_json_, &F__json_oer_, NULL, TTCN_Typedescriptor_t::DONTCARE };
UNIVERSAL_CHARSTRING F__json_default_coding("JSON");
TTCN_Module module_object("JsonBasicTypeF", __DATE__, __TIME__, module_checksum, NULL, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_6,
  current_runtime_version.requires_patch_level_1,  current_runtime_version.requires_runtime_1);

/* Bodies of functions, altsteps and testcases */

void F__json_encoder(const FLOAT& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, TRUE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `float' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf;
input_value.encode(F__json_descr_, ttcn_buf, coding_type, extra_options);
ttcn_buf.get_string(output_stream);
}

INTEGER F__json_decoder(OCTETSTRING& input_stream, FLOAT& output_value, const UNIVERSAL_CHARSTRING& coding_name)
{
TTCN_EncDec::coding_t coding_type;
unsigned int extra_options = 0;
TTCN_EncDec::get_coding_from_str(coding_name, &coding_type, &extra_options, FALSE);
if (coding_type != TTCN_EncDec::CT_JSON) {
TTCN_Logger::begin_event_log2str();
coding_name.log();
TTCN_error("Type `float' does not support %s encoding", (const char*) TTCN_Logger::end_event_log2str());
}
TTCN_Buffer ttcn_buf(input_stream);
output_value.decode(F__json_descr_, ttcn_buf, coding_type, extra_options);
switch (TTCN_EncDec::get_last_error_type()) {
case TTCN_EncDec::ET_NONE:
ttcn_buf.cut();
ttcn_buf.get_string(input_stream);
return 0;
case TTCN_EncDec::ET_INCOMPL_MSG:
case TTCN_EncDec::ET_LEN_ERR:
return 2;
default:
return 1;
}
}


} /* end of namespace */
