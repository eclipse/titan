// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R6B
// for U-ERICSSON\ethbaat (ethbaat@HU-00000670) on Thu Feb 20 17:43:37 2020

// Copyright (c) 2000-2019 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef JsonBasicEncDecTest__bs_HH
#define JsonBasicEncDecTest__bs_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>
#include "JsonEncDecFunctions.hh"

#if TTCN3_VERSION != 60601
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef WIN32
#error This file should be compiled on WIN32
#endif

#undef JsonBasicEncDecTest__bs_HH
#endif

namespace JsonBasicEncDecTest__bs {

/* Forward declarations of classes */

class RoU;
class RoU_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__BITSTRING RoBS;
typedef PreGenRecordOf::PREGEN__RECORD__OF__BITSTRING_template RoBS_template;
class anytype;
class anytype_template;

} /* end of namespace */

#ifndef JsonBasicEncDecTest__bs_HH
#define JsonBasicEncDecTest__bs_HH

namespace JsonBasicEncDecTest__bs {

/* Type definitions */

typedef COMPONENT CT;
typedef COMPONENT_template CT_template;
typedef INTEGER I;
typedef INTEGER_template I_template;
typedef CHARSTRING CS;
typedef CHARSTRING_template CS_template;

/* Class definitions */

class RoU : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
JsonBasicTypes::U__json **value_elements;
} *val_ptr;

static const JsonBasicTypes::U__json UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const RoU& other_value);

public:
  typedef JsonBasicTypes::U__json of_type;
RoU();
RoU(null_type other_value);
RoU(const RoU& other_value);
~RoU();

void clean_up();
RoU& operator=(null_type other_value);
RoU& operator=(const RoU& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const RoU& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RoU& other_value) const { return !(*this == other_value); }

JsonBasicTypes::U__json& operator[](int index_value);
JsonBasicTypes::U__json& operator[](const INTEGER& index_value);
const JsonBasicTypes::U__json& operator[](int index_value) const;
const JsonBasicTypes::U__json& operator[](const INTEGER& index_value) const;

RoU operator<<=(int rotate_count) const;
RoU operator<<=(const INTEGER& rotate_count) const;
RoU operator>>=(int rotate_count) const;
RoU operator>>=(const INTEGER& rotate_count) const;

RoU operator+(const RoU& other_value) const;

RoU substr(int index, int returncount) const;

RoU replace(int index, int len, const RoU& repl) const;

RoU replace(int index, int len, const RoU_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean, int p_chosen_field = CHOSEN_FIELD_UNSET);
};

class RoU_template : public Record_Of_Template {
union {
struct {
int n_elements;
JsonBasicTypes::U__json_template **value_elements;
} single_value;
struct {
unsigned int n_values;
RoU_template *list_value;
} value_list;
};
void copy_value(const RoU& other_value);
void copy_template(const RoU_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
RoU_template();
RoU_template(template_sel other_value);
RoU_template(null_type other_value);
RoU_template(const RoU& other_value);
RoU_template(const OPTIONAL<RoU>& other_value);
RoU_template(const RoU_template& other_value);
~RoU_template();

void clean_up();
RoU_template& operator=(template_sel other_value);
RoU_template& operator=(null_type other_value);
RoU_template& operator=(const RoU& other_value);
RoU_template& operator=(const OPTIONAL<RoU>& other_value);
RoU_template& operator=(const RoU_template& other_value);

JsonBasicTypes::U__json_template& operator[](int index_value);
JsonBasicTypes::U__json_template& operator[](const INTEGER& index_value);
const JsonBasicTypes::U__json_template& operator[](int index_value) const;
const JsonBasicTypes::U__json_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const RoU& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
RoU valueof() const;
RoU substr(int index, int returncount) const;

RoU replace(int index, int len, const RoU_template& repl) const;

RoU replace(int index, int len, const RoU& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
RoU_template& list_item(unsigned int list_index);
void log() const;
void log_match(const RoU& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class anytype : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_I = 1, ALT_CS = 2 };
private:
union_selection_type union_selection;
union {
INTEGER *field_I;
CHARSTRING *field_CS;
};
void copy_value(const anytype& other_value);

public:
anytype();
anytype(const anytype& other_value);
~anytype();
anytype& operator=(const anytype& other_value);
boolean operator==(const anytype& other_value) const;
inline boolean operator!=(const anytype& other_value) const { return !(*this == other_value); }
INTEGER& AT_I();
const INTEGER& AT_I() const;
CHARSTRING& AT_CS();
const CHARSTRING& AT_CS() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean, int p_chosen_field = CHOSEN_FIELD_UNSET);
};

class anytype_template : public Base_Template {
union {
struct {
anytype::union_selection_type union_selection;
union {
INTEGER_template *field_I;
CHARSTRING_template *field_CS;
};
} single_value;
struct {
unsigned int n_values;
anytype_template *list_value;
} value_list;
};
void copy_value(const anytype& other_value);

void copy_template(const anytype_template& other_value);

public:
anytype_template();
anytype_template(template_sel other_value);
anytype_template(const anytype& other_value);
anytype_template(const OPTIONAL<anytype>& other_value);
anytype_template(const anytype_template& other_value);
~anytype_template();
void clean_up();
anytype_template& operator=(template_sel other_value);
anytype_template& operator=(const anytype& other_value);
anytype_template& operator=(const OPTIONAL<anytype>& other_value);
anytype_template& operator=(const anytype_template& other_value);
boolean match(const anytype& other_value, boolean legacy = FALSE) const;
boolean is_value() const;anytype valueof() const;
anytype_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
INTEGER_template& AT_I();
const INTEGER_template& AT_I() const;
CHARSTRING_template& AT_CS();
const CHARSTRING_template& AT_CS() const;
boolean ischosen(anytype::union_selection_type checked_selection) const;
void log() const;
void log_match(const anytype& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};


/* Function prototypes */

extern void f__compare__bitstring(const BITSTRING& pl__val, const BITSTRING& pl__expected);
extern verdicttype testcase_tc__jsonBasic__encdec__integer(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__float1(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__float2(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__float3(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__float4(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__enum(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__bool1(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__bool2(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__bitstring(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__charstring(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__hexstring(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__octetstring(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__ucharstring(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__verdict(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__record(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__set(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__AI3(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__roi1(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__roi2(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__soi1(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__soi2(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__soi3(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__jsonBasic__encdec__union__const(boolean has_timer, double timer_value);
extern boolean operator==(null_type null_value, const RoU& other_value);
inline boolean operator!=(null_type null_value, const RoU& other_value) { return !(null_value == other_value); }
extern void RoU_encoder(const RoU& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER RoU_decoder(OCTETSTRING& input_stream, RoU& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void RoBS_0_encoder(const BITSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER RoBS_0_decoder(OCTETSTRING& input_stream, BITSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void RoBS_encoder(const RoBS& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER RoBS_decoder(OCTETSTRING& input_stream, RoBS& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern verdicttype testcase_tc__jsonBasic__encdec__union(boolean has_timer, double timer_value);
extern void I_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER I_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void CS_encoder(const CHARSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER CS_decoder(OCTETSTRING& input_stream, CHARSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern verdicttype testcase_tc__jsonBasic__encdec__anytype__i(boolean has_timer, double timer_value);
extern void anytype_encoder(const anytype& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER anytype_decoder(OCTETSTRING& input_stream, anytype& output_value, const UNIVERSAL_CHARSTRING& coding_name);

/* Global variable declarations */

extern const TTCN_Typedescriptor_t CT_descr_;
extern const TTCN_JSONdescriptor_t RoU_json_;
extern const TTCN_Typedescriptor_t RoU_descr_;
extern const TTCN_Typedescriptor_t RoU_0_descr_;
extern UNIVERSAL_CHARSTRING RoU_0_default_coding;
extern UNIVERSAL_CHARSTRING RoU_default_coding;
extern const TTCN_JSONdescriptor_t RoBS_json_;
extern const TTCN_Typedescriptor_t RoBS_descr_;
extern const XERdescriptor_t RoBS_0_xer_;
extern const TTCN_Typedescriptor_t RoBS_0_descr_;
extern UNIVERSAL_CHARSTRING RoBS_0_default_coding;
extern UNIVERSAL_CHARSTRING RoBS_default_coding;
extern const XERdescriptor_t I_xer_;
extern const TTCN_Typedescriptor_t I_descr_;
extern UNIVERSAL_CHARSTRING I_default_coding;
extern const XERdescriptor_t CS_xer_;
extern const TTCN_Typedescriptor_t CS_descr_;
extern UNIVERSAL_CHARSTRING CS_default_coding;
extern const TTCN_JSONdescriptor_t anytype_json_;
extern const TTCN_Typedescriptor_t anytype_descr_;
extern const XERdescriptor_t anytype_I_xer_;
extern const TTCN_OERdescriptor_t anytype_I_oer_;
extern const TTCN_Typedescriptor_t anytype_I_descr_;
extern UNIVERSAL_CHARSTRING anytype_I_default_coding;
extern const XERdescriptor_t anytype_CS_xer_;
extern const TTCN_Typedescriptor_t anytype_CS_descr_;
extern UNIVERSAL_CHARSTRING anytype_CS_default_coding;
extern UNIVERSAL_CHARSTRING anytype_default_coding;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
