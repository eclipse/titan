// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R6B
// for U-ERICSSON\ethbaat (ethbaat@HU-00000670) on Thu Feb 20 17:43:37 2020

// Copyright (c) 2000-2019 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef JsonBasicAttributeTest_HH
#define JsonBasicAttributeTest_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 60601
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef WIN32
#error This file should be compiled on WIN32
#endif

#undef JsonBasicAttributeTest_HH
#endif

namespace JsonBasicAttributeTest {

/* Forward declarations of classes */

class R0__json;
class R0__json_template;
class R1__json;
class R1__json_template;
class R2__json;
class R2__json_template;
class R3__json;
class R3__json_template;
class R4__json;
class R4__json_template;

} /* end of namespace */

#ifndef JsonBasicAttributeTest_HH
#define JsonBasicAttributeTest_HH

namespace JsonBasicAttributeTest {

/* Type definitions */

typedef COMPONENT CT;
typedef COMPONENT_template CT_template;

/* Class definitions */

class R0__json : public Base_Type {
  OPTIONAL<INTEGER> field_i;
public:
  R0__json();
  R0__json(const OPTIONAL<INTEGER>& par_i);
  R0__json(const R0__json& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  R0__json& operator=(const R0__json& other_value);
  boolean operator==(const R0__json& other_value) const;
  inline boolean operator!=(const R0__json& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& i()
    {return field_i;}
  inline const OPTIONAL<INTEGER>& i() const
    {return field_i;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean, int p_chosen_field = CHOSEN_FIELD_UNSET);
};

class R0__json_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
R0__json_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const R0__json& other_value);
void copy_template(const R0__json_template& other_value);

public:
R0__json_template();
R0__json_template(template_sel other_value);
R0__json_template(const R0__json& other_value);
R0__json_template(const OPTIONAL<R0__json>& other_value);
R0__json_template(const R0__json_template& other_value);
~R0__json_template();
R0__json_template& operator=(template_sel other_value);
R0__json_template& operator=(const R0__json& other_value);
R0__json_template& operator=(const OPTIONAL<R0__json>& other_value);
R0__json_template& operator=(const R0__json_template& other_value);
boolean match(const R0__json& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
R0__json valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
R0__json_template& list_item(unsigned int list_index) const;
INTEGER_template& i();
const INTEGER_template& i() const;
int size_of() const;
void log() const;
void log_match(const R0__json& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class R1__json : public Base_Type {
  OPTIONAL<INTEGER> field_i;
public:
  R1__json();
  R1__json(const OPTIONAL<INTEGER>& par_i);
  R1__json(const R1__json& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  R1__json& operator=(const R1__json& other_value);
  boolean operator==(const R1__json& other_value) const;
  inline boolean operator!=(const R1__json& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& i()
    {return field_i;}
  inline const OPTIONAL<INTEGER>& i() const
    {return field_i;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean, int p_chosen_field = CHOSEN_FIELD_UNSET);
};

class R1__json_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
R1__json_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const R1__json& other_value);
void copy_template(const R1__json_template& other_value);

public:
R1__json_template();
R1__json_template(template_sel other_value);
R1__json_template(const R1__json& other_value);
R1__json_template(const OPTIONAL<R1__json>& other_value);
R1__json_template(const R1__json_template& other_value);
~R1__json_template();
R1__json_template& operator=(template_sel other_value);
R1__json_template& operator=(const R1__json& other_value);
R1__json_template& operator=(const OPTIONAL<R1__json>& other_value);
R1__json_template& operator=(const R1__json_template& other_value);
boolean match(const R1__json& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
R1__json valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
R1__json_template& list_item(unsigned int list_index) const;
INTEGER_template& i();
const INTEGER_template& i() const;
int size_of() const;
void log() const;
void log_match(const R1__json& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class R2__json : public Base_Type {
  OPTIONAL<INTEGER> field_i;
public:
  R2__json();
  R2__json(const OPTIONAL<INTEGER>& par_i);
  R2__json(const R2__json& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  R2__json& operator=(const R2__json& other_value);
  boolean operator==(const R2__json& other_value) const;
  inline boolean operator!=(const R2__json& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& i()
    {return field_i;}
  inline const OPTIONAL<INTEGER>& i() const
    {return field_i;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean, int p_chosen_field = CHOSEN_FIELD_UNSET);
};

class R2__json_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
R2__json_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const R2__json& other_value);
void copy_template(const R2__json_template& other_value);

public:
R2__json_template();
R2__json_template(template_sel other_value);
R2__json_template(const R2__json& other_value);
R2__json_template(const OPTIONAL<R2__json>& other_value);
R2__json_template(const R2__json_template& other_value);
~R2__json_template();
R2__json_template& operator=(template_sel other_value);
R2__json_template& operator=(const R2__json& other_value);
R2__json_template& operator=(const OPTIONAL<R2__json>& other_value);
R2__json_template& operator=(const R2__json_template& other_value);
boolean match(const R2__json& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
R2__json valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
R2__json_template& list_item(unsigned int list_index) const;
INTEGER_template& i();
const INTEGER_template& i() const;
int size_of() const;
void log() const;
void log_match(const R2__json& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class R3__json : public Base_Type {
  OPTIONAL<INTEGER> field_i;
public:
  R3__json();
  R3__json(const OPTIONAL<INTEGER>& par_i);
  R3__json(const R3__json& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  R3__json& operator=(const R3__json& other_value);
  boolean operator==(const R3__json& other_value) const;
  inline boolean operator!=(const R3__json& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& i()
    {return field_i;}
  inline const OPTIONAL<INTEGER>& i() const
    {return field_i;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean, int p_chosen_field = CHOSEN_FIELD_UNSET);
};

class R3__json_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
R3__json_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const R3__json& other_value);
void copy_template(const R3__json_template& other_value);

public:
R3__json_template();
R3__json_template(template_sel other_value);
R3__json_template(const R3__json& other_value);
R3__json_template(const OPTIONAL<R3__json>& other_value);
R3__json_template(const R3__json_template& other_value);
~R3__json_template();
R3__json_template& operator=(template_sel other_value);
R3__json_template& operator=(const R3__json& other_value);
R3__json_template& operator=(const OPTIONAL<R3__json>& other_value);
R3__json_template& operator=(const R3__json_template& other_value);
boolean match(const R3__json& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
R3__json valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
R3__json_template& list_item(unsigned int list_index) const;
INTEGER_template& i();
const INTEGER_template& i() const;
int size_of() const;
void log() const;
void log_match(const R3__json& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class R4__json : public Base_Type {
  OPTIONAL<INTEGER> field_i;
public:
  R4__json();
  R4__json(const OPTIONAL<INTEGER>& par_i);
  R4__json(const R4__json& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  R4__json& operator=(const R4__json& other_value);
  boolean operator==(const R4__json& other_value) const;
  inline boolean operator!=(const R4__json& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& i()
    {return field_i;}
  inline const OPTIONAL<INTEGER>& i() const
    {return field_i;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean, int p_chosen_field = CHOSEN_FIELD_UNSET);
};

class R4__json_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
R4__json_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const R4__json& other_value);
void copy_template(const R4__json_template& other_value);

public:
R4__json_template();
R4__json_template(template_sel other_value);
R4__json_template(const R4__json& other_value);
R4__json_template(const OPTIONAL<R4__json>& other_value);
R4__json_template(const R4__json_template& other_value);
~R4__json_template();
R4__json_template& operator=(template_sel other_value);
R4__json_template& operator=(const R4__json& other_value);
R4__json_template& operator=(const OPTIONAL<R4__json>& other_value);
R4__json_template& operator=(const R4__json_template& other_value);
boolean match(const R4__json& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
R4__json valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
R4__json_template& list_item(unsigned int list_index) const;
INTEGER_template& i();
const INTEGER_template& i() const;
int size_of() const;
void log() const;
void log_match(const R4__json& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern void f__compare__bitstring(const BITSTRING& pl__val, const BITSTRING& pl__expected);
extern void R0__json_i_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER R0__json_i_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void R0__json_encoder(const R0__json& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER R0__json_decoder(OCTETSTRING& input_stream, R0__json& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void R1__json_i_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER R1__json_i_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void R1__json_encoder(const R1__json& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER R1__json_decoder(OCTETSTRING& input_stream, R1__json& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void R2__json_i_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER R2__json_i_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void R2__json_encoder(const R2__json& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER R2__json_decoder(OCTETSTRING& input_stream, R2__json& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void R3__json_i_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER R3__json_i_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void R3__json_encoder(const R3__json& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER R3__json_decoder(OCTETSTRING& input_stream, R3__json& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void R4__json_i_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER R4__json_i_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void R4__json_encoder(const R4__json& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER R4__json_decoder(OCTETSTRING& input_stream, R4__json& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern verdicttype testcase_tc__attr0__0(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__attr0__1(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__attr1__0(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__attr1__1(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__attr2__0(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__attr2__1(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__attr3__0(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__attr3__1(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__attr4__0(boolean has_timer, double timer_value);
extern verdicttype testcase_tc__attr4__1(boolean has_timer, double timer_value);

/* Global variable declarations */

extern const TTCN_Typedescriptor_t& CT_descr_;
extern const TTCN_JSONdescriptor_t R0__json_json_;
extern const TTCN_Typedescriptor_t R0__json_descr_;
extern const XERdescriptor_t R0__json_i_xer_;
extern const TTCN_Typedescriptor_t R0__json_i_descr_;
extern UNIVERSAL_CHARSTRING R0__json_i_default_coding;
extern UNIVERSAL_CHARSTRING R0__json_default_coding;
extern const TTCN_JSONdescriptor_t R1__json_json_;
extern const TTCN_Typedescriptor_t R1__json_descr_;
extern const XERdescriptor_t R1__json_i_xer_;
extern const TTCN_JSONdescriptor_t R1__json_i_json_;
extern const TTCN_Typedescriptor_t R1__json_i_descr_;
extern UNIVERSAL_CHARSTRING R1__json_i_default_coding;
extern UNIVERSAL_CHARSTRING R1__json_default_coding;
extern const TTCN_JSONdescriptor_t R2__json_json_;
extern const TTCN_Typedescriptor_t R2__json_descr_;
extern const XERdescriptor_t R2__json_i_xer_;
extern const TTCN_JSONdescriptor_t R2__json_i_json_;
extern const TTCN_Typedescriptor_t R2__json_i_descr_;
extern UNIVERSAL_CHARSTRING R2__json_i_default_coding;
extern UNIVERSAL_CHARSTRING R2__json_default_coding;
extern const TTCN_JSONdescriptor_t R3__json_json_;
extern const TTCN_Typedescriptor_t R3__json_descr_;
extern const XERdescriptor_t R3__json_i_xer_;
extern const TTCN_JSONdescriptor_t R3__json_i_json_;
extern const TTCN_Typedescriptor_t R3__json_i_descr_;
extern UNIVERSAL_CHARSTRING R3__json_i_default_coding;
extern UNIVERSAL_CHARSTRING R3__json_default_coding;
extern const TTCN_JSONdescriptor_t R4__json_json_;
extern const TTCN_Typedescriptor_t R4__json_descr_;
extern const XERdescriptor_t R4__json_i_xer_;
extern const TTCN_Typedescriptor_t R4__json_i_descr_;
extern UNIVERSAL_CHARSTRING R4__json_i_default_coding;
extern UNIVERSAL_CHARSTRING R4__json_default_coding;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
