// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R6B
// for U-ERICSSON\ethbaat (ethbaat@HU-00000670) on Thu Feb 20 17:43:37 2020

// Copyright (c) 2000-2019 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef JsonBasicTypeAltstep_HH
#define JsonBasicTypeAltstep_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 60601
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef WIN32
#error This file should be compiled on WIN32
#endif

#undef JsonBasicTypeAltstep_HH
#endif

namespace JsonBasicTypeAltstep {

/* Forward declarations of classes */

class altstepref;
class altstepref_template;
class aref;
class aref_template;

} /* end of namespace */

#ifndef JsonBasicTypeAltstep_HH
#define JsonBasicTypeAltstep_HH

namespace JsonBasicTypeAltstep {

/* Class definitions */

class altstepref : public Base_Type {
public:
typedef void (*standalone_pointer)();
typedef Default_Base* (*activate_pointer)();
typedef alt_status (*function_pointer)();
private:
friend class altstepref_template;
friend boolean operator==(altstepref::function_pointer value, const altstepref& other_value);
function_pointer referred_function;
public:
altstepref();
altstepref(function_pointer other_value);
altstepref(const altstepref& other_value);
altstepref& operator=(function_pointer other_value);
altstepref& operator=(const altstepref& other_value);
boolean operator==(function_pointer other_value) const;
boolean operator==(const altstepref& other_value) const;
inline boolean operator!=(function_pointer other_value) const
{ return !(*this == other_value); }
inline boolean operator!=(const altstepref& other_value) const
{ return !(*this == other_value); }

void invoke_standalone() const;
Default_Base *activate() const;
alt_status invoke() const;
inline boolean is_bound() const { return referred_function != NULL; }
inline boolean is_value() const { return referred_function != NULL; }
inline void clean_up() { referred_function = NULL; }
inline void must_bound(const char *err_msg) const
{ if (referred_function == NULL) TTCN_error("%s", err_msg); }

inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

extern boolean operator==(altstepref::function_pointer value, const altstepref& other_value);
inline boolean operator!=(altstepref::function_pointer value, const altstepref& other_value)
{ return !(value == other_value); } 

class altstepref_template : public Base_Template {
union {
altstepref::function_pointer single_value;
struct {
unsigned int n_values;
altstepref_template *list_value;
} value_list;
};

  void copy_template(const altstepref_template& other_value);
public:
altstepref_template();
altstepref_template(template_sel other_value);
altstepref_template(altstepref::function_pointer other_value);
altstepref_template(const altstepref& other_value);
altstepref_template(const OPTIONAL<altstepref>& other_value);
altstepref_template(const altstepref_template& other_value);
~altstepref_template();
void clean_up();
altstepref_template& operator=(template_sel other_value);
altstepref_template& operator=(altstepref::function_pointer other_value);
altstepref_template& operator=(const altstepref& other_value);
altstepref_template& operator=(const OPTIONAL<altstepref>& other_value);
altstepref_template& operator=(const altstepref_template& other_value);
boolean match(altstepref::function_pointer other_value, boolean legacy = FALSE) const;
boolean match(const altstepref& other_value, boolean legacy = FALSE) const;
altstepref valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
altstepref_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const altstepref& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class aref : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_a = 1, ALT_d = 2 };
private:
union_selection_type union_selection;
union {
altstepref *field_a;
DEFAULT *field_d;
};
void copy_value(const aref& other_value);

public:
aref();
aref(const aref& other_value);
~aref();
aref& operator=(const aref& other_value);
boolean operator==(const aref& other_value) const;
inline boolean operator!=(const aref& other_value) const { return !(*this == other_value); }
altstepref& a();
const altstepref& a() const;
DEFAULT& d();
const DEFAULT& d() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class aref_template : public Base_Template {
union {
struct {
aref::union_selection_type union_selection;
union {
altstepref_template *field_a;
DEFAULT_template *field_d;
};
} single_value;
struct {
unsigned int n_values;
aref_template *list_value;
} value_list;
};
void copy_value(const aref& other_value);

void copy_template(const aref_template& other_value);

public:
aref_template();
aref_template(template_sel other_value);
aref_template(const aref& other_value);
aref_template(const OPTIONAL<aref>& other_value);
aref_template(const aref_template& other_value);
~aref_template();
void clean_up();
aref_template& operator=(template_sel other_value);
aref_template& operator=(const aref& other_value);
aref_template& operator=(const OPTIONAL<aref>& other_value);
aref_template& operator=(const aref_template& other_value);
boolean match(const aref& other_value, boolean legacy = FALSE) const;
boolean is_value() const;aref valueof() const;
aref_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
altstepref_template& a();
const altstepref_template& a() const;
DEFAULT_template& d();
const DEFAULT_template& d() const;
boolean ischosen(aref::union_selection_type checked_selection) const;
void log() const;
void log_match(const aref& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};


/* Global variable declarations */

extern const TTCN_Typedescriptor_t altstepref_descr_;
extern const TTCN_Typedescriptor_t aref_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
