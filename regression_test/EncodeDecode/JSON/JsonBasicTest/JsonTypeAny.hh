// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R6B
// for U-ERICSSON\ethbaat (ethbaat@HU-00000670) on Thu Feb 20 17:43:37 2020

// Copyright (c) 2000-2019 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef JsonTypeAny_HH
#define JsonTypeAny_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 60601
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef WIN32
#error This file should be compiled on WIN32
#endif

#undef JsonTypeAny_HH
#endif

namespace JsonTypeAny {

/* Forward declarations of classes */

class rat;
class rat_template;
class anytype;
class anytype_template;

} /* end of namespace */

#ifndef JsonTypeAny_HH
#define JsonTypeAny_HH

namespace JsonTypeAny {

/* Class definitions */

class rat : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
anytype **value_elements;
} *val_ptr;

static const anytype UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const rat& other_value);

public:
  typedef anytype of_type;
rat();
rat(null_type other_value);
rat(const rat& other_value);
~rat();

void clean_up();
rat& operator=(null_type other_value);
rat& operator=(const rat& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const rat& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const rat& other_value) const { return !(*this == other_value); }

anytype& operator[](int index_value);
anytype& operator[](const INTEGER& index_value);
const anytype& operator[](int index_value) const;
const anytype& operator[](const INTEGER& index_value) const;

rat operator<<=(int rotate_count) const;
rat operator<<=(const INTEGER& rotate_count) const;
rat operator>>=(int rotate_count) const;
rat operator>>=(const INTEGER& rotate_count) const;

rat operator+(const rat& other_value) const;

rat substr(int index, int returncount) const;

rat replace(int index, int len, const rat& repl) const;

rat replace(int index, int len, const rat_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class rat_template : public Record_Of_Template {
union {
struct {
int n_elements;
anytype_template **value_elements;
} single_value;
struct {
unsigned int n_values;
rat_template *list_value;
} value_list;
};
void copy_value(const rat& other_value);
void copy_template(const rat_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
rat_template();
rat_template(template_sel other_value);
rat_template(null_type other_value);
rat_template(const rat& other_value);
rat_template(const OPTIONAL<rat>& other_value);
rat_template(const rat_template& other_value);
~rat_template();

void clean_up();
rat_template& operator=(template_sel other_value);
rat_template& operator=(null_type other_value);
rat_template& operator=(const rat& other_value);
rat_template& operator=(const OPTIONAL<rat>& other_value);
rat_template& operator=(const rat_template& other_value);

anytype_template& operator[](int index_value);
anytype_template& operator[](const INTEGER& index_value);
const anytype_template& operator[](int index_value) const;
const anytype_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const rat& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
rat valueof() const;
rat substr(int index, int returncount) const;

rat replace(int index, int len, const rat_template& repl) const;

rat replace(int index, int len, const rat& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
rat_template& list_item(unsigned int list_index);
void log() const;
void log_match(const rat& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class anytype : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_INTEGER = 1, ALT_FLOAT = 2 };
private:
union_selection_type union_selection;
union {
INTEGER *field_INTEGER;
FLOAT *field_FLOAT;
};
void copy_value(const anytype& other_value);

public:
anytype();
anytype(const anytype& other_value);
~anytype();
anytype& operator=(const anytype& other_value);
boolean operator==(const anytype& other_value) const;
inline boolean operator!=(const anytype& other_value) const { return !(*this == other_value); }
INTEGER& AT_INTEGER();
const INTEGER& AT_INTEGER() const;
FLOAT& AT_FLOAT();
const FLOAT& AT_FLOAT() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class anytype_template : public Base_Template {
union {
struct {
anytype::union_selection_type union_selection;
union {
INTEGER_template *field_INTEGER;
FLOAT_template *field_FLOAT;
};
} single_value;
struct {
unsigned int n_values;
anytype_template *list_value;
} value_list;
};
void copy_value(const anytype& other_value);

void copy_template(const anytype_template& other_value);

public:
anytype_template();
anytype_template(template_sel other_value);
anytype_template(const anytype& other_value);
anytype_template(const OPTIONAL<anytype>& other_value);
anytype_template(const anytype_template& other_value);
~anytype_template();
void clean_up();
anytype_template& operator=(template_sel other_value);
anytype_template& operator=(const anytype& other_value);
anytype_template& operator=(const OPTIONAL<anytype>& other_value);
anytype_template& operator=(const anytype_template& other_value);
boolean match(const anytype& other_value, boolean legacy = FALSE) const;
boolean is_value() const;anytype valueof() const;
anytype_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
INTEGER_template& AT_INTEGER();
const INTEGER_template& AT_INTEGER() const;
FLOAT_template& AT_FLOAT();
const FLOAT_template& AT_FLOAT() const;
boolean ischosen(anytype::union_selection_type checked_selection) const;
void log() const;
void log_match(const anytype& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const rat& other_value);
inline boolean operator!=(null_type null_value, const rat& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const TTCN_Typedescriptor_t rat_descr_;
extern const TTCN_Typedescriptor_t anytype_descr_;
extern const XERdescriptor_t anytype_INTEGER_xer_;
extern const TTCN_Typedescriptor_t anytype_INTEGER_descr_;
extern const XERdescriptor_t anytype_FLOAT_xer_;
extern const TTCN_OERdescriptor_t anytype_FLOAT_oer_;
extern const TTCN_Typedescriptor_t anytype_FLOAT_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
