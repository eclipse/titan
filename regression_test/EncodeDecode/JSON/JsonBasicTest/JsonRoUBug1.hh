// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R6B
// for U-ERICSSON\ethbaat (ethbaat@HU-00000670) on Thu Feb 20 17:43:37 2020

// Copyright (c) 2000-2019 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef JsonRoUBug1_HH
#define JsonRoUBug1_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 60601
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef WIN32
#error This file should be compiled on WIN32
#endif

#undef JsonRoUBug1_HH
#endif

namespace JsonRoUBug1 {

/* Forward declarations of classes */

class RoU;
class RoU_template;
class U__json;
class U__json_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER RoI__json;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template RoI__json_template;

} /* end of namespace */

#ifndef JsonRoUBug1_HH
#define JsonRoUBug1_HH

namespace JsonRoUBug1 {

/* Type definitions */

typedef COMPONENT CT;
typedef COMPONENT_template CT_template;
typedef INTEGER I__json;
typedef INTEGER_template I__json_template;
typedef BITSTRING BS__json;
typedef BITSTRING_template BS__json_template;

/* Class definitions */

class RoU : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
U__json **value_elements;
} *val_ptr;

static const U__json UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const RoU& other_value);

public:
  typedef U__json of_type;
RoU();
RoU(null_type other_value);
RoU(const RoU& other_value);
~RoU();

void clean_up();
RoU& operator=(null_type other_value);
RoU& operator=(const RoU& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const RoU& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RoU& other_value) const { return !(*this == other_value); }

U__json& operator[](int index_value);
U__json& operator[](const INTEGER& index_value);
const U__json& operator[](int index_value) const;
const U__json& operator[](const INTEGER& index_value) const;

RoU operator<<=(int rotate_count) const;
RoU operator<<=(const INTEGER& rotate_count) const;
RoU operator>>=(int rotate_count) const;
RoU operator>>=(const INTEGER& rotate_count) const;

RoU operator+(const RoU& other_value) const;

RoU substr(int index, int returncount) const;

RoU replace(int index, int len, const RoU& repl) const;

RoU replace(int index, int len, const RoU_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean, int p_chosen_field = CHOSEN_FIELD_UNSET);
};

class RoU_template : public Record_Of_Template {
union {
struct {
int n_elements;
U__json_template **value_elements;
} single_value;
struct {
unsigned int n_values;
RoU_template *list_value;
} value_list;
};
void copy_value(const RoU& other_value);
void copy_template(const RoU_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
RoU_template();
RoU_template(template_sel other_value);
RoU_template(null_type other_value);
RoU_template(const RoU& other_value);
RoU_template(const OPTIONAL<RoU>& other_value);
RoU_template(const RoU_template& other_value);
~RoU_template();

void clean_up();
RoU_template& operator=(template_sel other_value);
RoU_template& operator=(null_type other_value);
RoU_template& operator=(const RoU& other_value);
RoU_template& operator=(const OPTIONAL<RoU>& other_value);
RoU_template& operator=(const RoU_template& other_value);

U__json_template& operator[](int index_value);
U__json_template& operator[](const INTEGER& index_value);
const U__json_template& operator[](int index_value) const;
const U__json_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const RoU& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
RoU valueof() const;
RoU substr(int index, int returncount) const;

RoU replace(int index, int len, const RoU_template& repl) const;

RoU replace(int index, int len, const RoU& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
RoU_template& list_item(unsigned int list_index);
void log() const;
void log_match(const RoU& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class U__json : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_i = 1, ALT_bs = 2 };
private:
union_selection_type union_selection;
union {
INTEGER *field_i;
BITSTRING *field_bs;
};
void copy_value(const U__json& other_value);

public:
U__json();
U__json(const U__json& other_value);
~U__json();
U__json& operator=(const U__json& other_value);
boolean operator==(const U__json& other_value) const;
inline boolean operator!=(const U__json& other_value) const { return !(*this == other_value); }
INTEGER& i();
const INTEGER& i() const;
BITSTRING& bs();
const BITSTRING& bs() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean, int p_chosen_field = CHOSEN_FIELD_UNSET);
};

class U__json_template : public Base_Template {
union {
struct {
U__json::union_selection_type union_selection;
union {
INTEGER_template *field_i;
BITSTRING_template *field_bs;
};
} single_value;
struct {
unsigned int n_values;
U__json_template *list_value;
} value_list;
};
void copy_value(const U__json& other_value);

void copy_template(const U__json_template& other_value);

public:
U__json_template();
U__json_template(template_sel other_value);
U__json_template(const U__json& other_value);
U__json_template(const OPTIONAL<U__json>& other_value);
U__json_template(const U__json_template& other_value);
~U__json_template();
void clean_up();
U__json_template& operator=(template_sel other_value);
U__json_template& operator=(const U__json& other_value);
U__json_template& operator=(const OPTIONAL<U__json>& other_value);
U__json_template& operator=(const U__json_template& other_value);
boolean match(const U__json& other_value, boolean legacy = FALSE) const;
boolean is_value() const;U__json valueof() const;
U__json_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
INTEGER_template& i();
const INTEGER_template& i() const;
BITSTRING_template& bs();
const BITSTRING_template& bs() const;
boolean ischosen(U__json::union_selection_type checked_selection) const;
void log() const;
void log_match(const U__json& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};


/* Function prototypes */

extern void I__json_encoder(const INTEGER& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER I__json_decoder(OCTETSTRING& input_stream, INTEGER& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void BS__json_encoder(const BITSTRING& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER BS__json_decoder(OCTETSTRING& input_stream, BITSTRING& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern boolean operator==(null_type null_value, const RoU& other_value);
inline boolean operator!=(null_type null_value, const RoU& other_value) { return !(null_value == other_value); }
extern void U__json_encoder(const U__json& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER U__json_decoder(OCTETSTRING& input_stream, U__json& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void RoU_encoder(const RoU& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER RoU_decoder(OCTETSTRING& input_stream, RoU& output_value, const UNIVERSAL_CHARSTRING& coding_name);
extern void RoI__json_encoder(const RoI__json& input_value, OCTETSTRING& output_stream, const UNIVERSAL_CHARSTRING& coding_name);
extern INTEGER RoI__json_decoder(OCTETSTRING& input_stream, RoI__json& output_value, const UNIVERSAL_CHARSTRING& coding_name);

/* Global variable declarations */

extern const TTCN_Typedescriptor_t CT_descr_;
extern const XERdescriptor_t I__json_xer_;
extern const TTCN_Typedescriptor_t I__json_descr_;
extern UNIVERSAL_CHARSTRING I__json_default_coding;
extern const XERdescriptor_t BS__json_xer_;
extern const TTCN_Typedescriptor_t BS__json_descr_;
extern UNIVERSAL_CHARSTRING BS__json_default_coding;
extern const TTCN_JSONdescriptor_t RoU_json_;
extern const TTCN_Typedescriptor_t RoU_descr_;
extern const TTCN_JSONdescriptor_t U__json_json_;
extern const TTCN_Typedescriptor_t U__json_descr_;
extern const XERdescriptor_t U__json_i_xer_;
extern const TTCN_OERdescriptor_t U__json_i_oer_;
extern const TTCN_Typedescriptor_t U__json_i_descr_;
extern UNIVERSAL_CHARSTRING U__json_i_default_coding;
extern const XERdescriptor_t U__json_bs_xer_;
extern const TTCN_OERdescriptor_t U__json_bs_oer_;
extern const TTCN_Typedescriptor_t U__json_bs_descr_;
extern UNIVERSAL_CHARSTRING U__json_bs_default_coding;
extern UNIVERSAL_CHARSTRING U__json_default_coding;
extern const TTCN_Typedescriptor_t RoU_0_descr_;
extern UNIVERSAL_CHARSTRING RoU_0_default_coding;
extern UNIVERSAL_CHARSTRING RoU_default_coding;
extern const TTCN_JSONdescriptor_t RoI__json_json_;
extern const TTCN_Typedescriptor_t RoI__json_descr_;
extern const XERdescriptor_t RoI__json_0_xer_;
extern const TTCN_OERdescriptor_t RoI__json_0_oer_;
extern const TTCN_Typedescriptor_t RoI__json_0_descr_;
extern UNIVERSAL_CHARSTRING RoI__json_0_default_coding;
extern UNIVERSAL_CHARSTRING RoI__json_default_coding;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
